#!/usr/bin/env bash

# Phases:
# 1. Run unit tests
# 2. Build application and create artifacts
# 3. Deploy infrastructure and application code
# 4. Run integration tests
# 5. If all tests pass, deploy to production (currently imaginary). Else, deploy previous artifact

# Template from https://dbwebb.se/kunskap/create-bash-script-with-options-commands-and-arguments

# Exit values:
# 0 on success
# 1 on failure

# Name of script
SCRIPT=$( basename "$0" ) 

# Current script version
VERSION="0.0.1"

#
# Message to display the usage and help
#
function usage {
    local txt=(
"Build script for serverless applications"
"Usage: $SCRIPT [options] <command> [arguments]"
""
"Commands:"
"  build             Build the application code"
"  test              Run the application tests"
"  deploy            Deploy the the application to cloud"
""
"Options:"
"  --help, -h        Print help"
"  --version, -v     Print version"

    )
    printf "%s\n" "${txt[@]}"
}

#
# Message to display if the tool is incorrectly used
#
function badusage {
    local message="$1"
    local txt=(
"For an overview of the command, execute:"
"$SCRIPT --help"
    )

    [[ $message ]] && printf "$message\n"

    printf "%s\n" "${txt[@]}"
}

#
# Message to display the version
#
function version {
    local txt=(
"$SCRIPT version $VERSION"
    )
    printf "%s\n" "${txt[@]}"
}

#
# Builds the application code and creates build artifacts
#
function app-build {
  # TODO:
  # install dependencies
  # build app
  # zip dependencies
  # zip app
    local txt=(
"Building application with params: $*"
    )
    printf "%s\n" "${txt[@]}"
}

#
# Tests the application code
#
function app-test {
    local txt=(
"Running tests with params: $*"
    )
    printf "%s\n" "${txt[@]}"
}

#
# Deploys the application
#
function app-deploy {
    local txt=(
"Deploying application with params: $*"
    )
    printf "%s\n" "${txt[@]}"
}

#
# Process options
#
while(( $# ))
do
    case "$1" in

        --help | -h)
            usage
            exit 0
        ;;

        --version | -v)
            version
            exit 0
        ;;

        build \
        | test)
            command=$1
            shift   # shifts positional arguments passed
            app-$command $* # call the command and pass in the remaining commands, the commands will be indexed from $1 from the perspective of the command
            exit 0
        ;;

        *)
            badusage "Option/Command not recognized"
            exit 1
        ;;
    # TODO: Add build, test and deploy, rollback? functions
    esac
done

badusage
exit 1
